\numberlist{

	\item \question{What do you know about pandas?}
	  
	\answer{
	   \newlist{
	      \item Pandas is an open-source, python-based library used in data manipulation applications requiring high performance. The name is derived from “Panel Data” having multidimensional data. This was developed in 2008 by Wes McKinney and was developed for data analysis.
	      \item Pandas are useful in performing 5 major steps of data analysis - Load the data, clean/manipulate it, prepare it, model it, and analyze the data.}
	      }
	 
	 \item \question{Define pandas dataframe.?}
	 
     \answer {A dataframe is a 2D mutable and tabular structure for representing data labelled with axes - rows and columns.
     \\
     \textbf{The syntax for creating dataframe:}
	   
	 \codeblock{
	 import pandas as pd
	 \\
     dataframe = pd.DataFrame( data, index, columns, dtype) }
	 
	 
	 \newlist{
	     \item data - Represents various forms like series, map, ndarray, lists, dict etc.
         \item index - Optional argument that represents an index to row labels.
         \item columns - Optional argument for column labels.
         \item Dtype - the data type of each column. Again optional.}
	 
	 }
	 
	 
	 \item \question{How will you combine different pandas dataframes?}
	 
	 \answer{The dataframes can be combines using the below approaches:
	   \\
	 \textbf{append() method}: This is used to stack the dataframes horizontally. Syntax:
	 \codeblock{
	   df1.append(df2) }
	   
	 \textbf{concat()method}:This is used to stack dataframes vertically. This is best used when the dataframes have the same columns and similar fields. Syntax:
	 
	 \codeblock{
     pd.concat([df1, df2]) }
     
     \textbf{join()method}: This is used for extracting data from various dataframes having one or more common columns.
     
     \codeblock{
     df1.join(df2)
     }
     
     }
	 
	 \item \question{Can you create a series from the dictionary object in
pandas?}
	 \answer{One dimensional array capable of storing different data types is called a series. We
can create pandas series from a dictionary object as shown below:
	 
	 \codeblock{
	    import pandas as pd
	   \\
        dict\_info = {'key1' : 2.0, 'key2' : 3.1, 'key3' : 2.2}
\\
        series\_obj = pd.Series(dict\_info)
        \\
        print (series\_obj)
\\
        Output:
        \\
        x 2.0
        \\
        y 3.1
\\
        z 2.2
\\
       dtype: float64}
	 
		If an index is not specified in the input method, then the keys of the dictionaries are sorted in ascending order for constructing the index. In case the index is passed, then values of the index label will be extracted from the dictionary. }
	 
	 \item \question{. How will you identify and deal with missing values in a
dataframe?}
	 
	 \answer{We can identify if a dataframe has missing values by using the isnull() and isna() methods.
	 
	 \codeblock{
	    missing\_data\_count=df.isnull().sum()}

	 We can handle missing values by either replacing the values in the column with 0 as follows:

	 \codeblock{
	    	df[‘column\_name’].fillna(0)
	 }
	 
	 Or by replacing it with the mean value of the column
     
     \codeblock{
     {df[‘column\_name’] = df[‘column\_name’].fillna((df[‘column\_name’].mean())}

	 }
	 
	 }
	
	\item \question{What do you understand by reindexing in pandas? }
	
	\answer{Reindexing is the process of conforming a dataframe to a new index with optional filling logic. If the values are missing in the previous index, then NaN/NA is placed in the location. A new object is returned unless a new index is produced that is equivalent to the current one. The copy value is set to False. This is also used for changing the index of rows and columns in the dataframe.}
	
	
	\item \question {How to add new column to pandas dataframe?}
	
	\answer{A new column can be added to a pandas dataframe as follows}
	
	\codeblock{
	  import pandas as pd
	  \\
      data\_info = {'first' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
      \\
      'second' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
\\
\\
      df = pd.DataFrame(data\_info)
\\
      \# To add new column third
\\
      df['third']=pd.Series([10,20,30],index=['a','b','c'])
\\
      print (df)
\\
    \# To add new column fourth
\\
      df['fourth']=df['first']+info['third']
\\
       print (df) }
	
	
	\item \question{How will you delete indices, rows and columns from a
dataframe?}
    \answer{\textbf{To delete an Index:}
       \newlist{
          \item Execute del df.index.name for removing the index by name.
          \item Alternatively, the df.index.name can be assigned to None.
          \item For example, if you have the below dataframe:
       
      \codeblock{
           \s \s \s Column 1
           \\
         Names
         \\
         John \s \s \s 1
         \\
         Jack \s \s \s 2
         \\
         Judy \s \s \s 3
         \\
         Jim \s \s  \s  4 }
      
          \item To drop the index name “Names”:
          
      \codeblock{
         df.index.name = None
         \\
         \# Or run the below:
         \\
         \# del df.index.name
         \\
          print(df)
          \\
         \s \s \s Column 1
         \\
         John \s \s \s 1
         \\
         Jack \s \s \s 2
         \\
         Judy \s \s \s 3
         \\
         Jim \s \s  \s  4   }
         }

      \newlist{
         \item drop() method is used to delete row/column from dataframe.
         \item The axis argument is passed to the drop method where if the value is 0, it indicates to drop/delete a row and if 1 it has to drop the column.
         \item Additionally, we can try to delete the rows/columns in place by setting the value of inplace to True. This makes sure that the job is done without the need for reassignment.
         \item The duplicate values from the row/column can be deleted by using the drop\_duplicates() method.}
      
      
      
      \item \question{Can you get items of series A that are not available in
another series B?}
      \answer{This can be achieved by using the (~not/negation symbol) and is in() method as shown below}
       \codeblock{
          import pandas as pd
\\
          df1 = pd.Series([2, 4, 8, 10, 12])
\\
          df2 = pd.Series([8, 12, 10, 15, 16])
\\
          df1=df1 [~df1.isin(df2)]
\\
          print(df1)
\\
          """
\\
          Output:
\\
          0  2
\\
          1  4
\\
          dtype: int64
\\
          """
}

      
      \item \question{How will you get the items that are not common to both the
given series A and B?}

      \answer{We can achieve this by first performing the union of both series, then taking the intersection of both series. Then we follow the approach of getting items of union that are not there in the list of the intersection.
      \\
The following code demonstrates this:}     
      
      \codeblock{
         import pandas as pd
         \\
         import numpy as np
\\
         df1 = pd.Series([2, 4, 5, 8, 10])
\\
         df2 = pd.Series([8, 10, 13, 15, 17])
\\
         p\_union = pd.Series(np.union1d(df1, df2)) \# union of series
\\
         p\_intersect = pd.Series(np.intersect1d(df1, df2)) \# intersection of series
\\
         unique\_elements = p\_union[~p\_union.isin(p\_intersect)]
\\
         print(unique\_elements)
\\
         """
\\
         Output:
\\
         0 2
\\
         1 4
\\
         2 5
\\
         5 13
\\
         6 15
\\
         7 17
\\
         dtype: int64
\\
         """   }

       
       \item \question{While importing data from different sources, can the pandas
library recognize dates?}
       \answer{Yes, they can, but with some bit of help. We need to add the parse_dates argument while we are reading data from the sources. Consider an example where we read data from a CSV file, we may encounter different date-time formats that are not readable by the pandas library. In this case, pandas provide flexibility to build our custom date parser with the help of lambda functions as shown below:}
       \codeblock{
           import pandas as pd
       \\
           from datetime import datetime
\\
           dateparser = lambda date\_val: datetime.strptime(date\_val, '%Y-%m-%d %H:%M:%S')
\\
           df = pd.read\_csv("some\_file.csv", parse\_dates=['datetime\_column'],
\\
          date\_parser=datepars }.
          

}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
