\numberlist{
	
	\item \question{How is memory managed in Python?}
	
	\answer{
		\newlist{
			\item Memory management in Python is handled by the \textbf{Python Memory Manager.} The memory allocated by the manager is in form of a \textbf{private heap space} dedicated to Python. All Python objects are stored in this heap and being
			private, it is inaccessible to the programmer. Though, python does provide some
			core API functions to work upon the private heap space.
			\item Additionally, Python has an in-built garbage collection to recycle the unused memory for the private heap space.}
	}
	
	
	\item \question{What are Python namespaces? Why are they used?}
	
	\answer{
		A namespace in Python ensures that object names in a program are unique and can be used without any conflict. Python implements these namespaces as dictionaries with 'name as key' mapped to a corresponding 'object as value'. This allows for multiple namespaces to use the same name and map it to a separate object. A few examples of namespaces are as follows:
		\newlist{
			\item \textbf{Local Namespace} includes local names inside a function. the namespace is temporarily created for a function call and gets cleared when the function
			returns.
			\item \textbf{Global Namespace}includes names from various imported packages/ modules that are being used in the current project. This namespace is created when the
			package is imported in the script and lasts until the execution of the script.
			\item \textbf{Built-in Namespace} includes built-in functions of core Python and built-in names for various types of exceptions.}
		The lifecycle of a namespace depends upon the scope of objects they are mapped to. If the scope of an object ends, the lifecycle of that namespace comes to an end. Hence, it isn't possible to access inner namespace objects from an outer namespace.
	}
	
	
	\item \question{What is Scope Resolution in Python?}
	
	\answer{
		Sometimes objects within the same scope have the same name but function differently. In such cases, scope resolution comes into play in Python automatically. A few examples of such behavior are:
		\newlist{
			\item Python modules namely 'math' and 'cmath' have a lot of functions that are common to both of them - log10(),acos(),exp() etc. To resolve this ambiguity, it is necessary to prefix them with their respective module, like math.exp() and cmath.exp().
			
			\item Consider the code below, an object temp has been initialized to 10 globally and then to 20 on function call. However, the function call didn't change the value of the temp globally. Here, we can observe that Python draws a clear line between global and local variables, treating their namespaces as separate identities.
		}
		
		
		\codeblock{
			temp = 10 \# global-scope variable \\
			\textbf{def}func(): \\
			\s \s temp = 20 \# local-scope variable \\
			\s \s print(temp) \\
			print(temp) \# output => 10 \\
			func() \# output => 20 \\
			print(temp) \# output => 10  
		}    
		
		This behaviour can be overridden using the global keyword inside the function, as shown in the following example:
		
		\codeblock{
			temp = 10 \# global-scope variable \\
			def func(): \\
			\s \s global temp \\
			\s \s temp = 20 \# local-scope variable \\
			\s \s print(temp) \\
			print(temp) \# output => 10 \\
			func() \# output => 20 \\
			print(temp) \# output => 20
		}
	}
	
	\item \textbf{ What are decorators in Python?}
	
	\answer{
		Decorators in Python are essentially functions that add functionality to an existing function in Python without changing the structure of the function itself. They are represented the @decorator\_name in Python and are called in a bottom-up fashion.
		For example:
		
		\codeblock{
			\# decorator function to convert to lowercase \\
			def lowercase\_decorator(function): \\
			\s def wrapper(): \\
			\s \s func = function() \\
			\s \s string\_lowercase = func.lower() \\
			\s \s return string\_lowercase \\
			\s return wrapper \\
			\# decorator function to split words \\
			def splitter\_decorator(function): \\
			\s def wrapper(): \\
			\s \s func = function() \\
			\s \s string\_split = func.split() \\
			\s \s \textbf{return} string\_split \\
			return wrapper \\
			@splitter\_decorator \# this is executed next \\
			@lowercase\_decorator \# this is executed first \\
			def hello(): \\
			\s return 'Hello World' \\
			hello ()   \#  output =>  [ 'hello' , 'world' ]
		}
		
		The beauty of the decorators lies in the fact that besides adding functionality to the output of the method, they can even \textbf{accept arguments} for functions and can further modify those arguments before passing it to the function itself. The \textbf{inner nested} function, i.e. 'wrapper' , plays a significant role here. It is implemented to enforce \textbf{encapsulation}  and thus, keep itself hidden from the global scope. 
		
		\codeblock{
			\# decorator function to capitalize names \\
			def names\_decorator(function): \\
			\s def wrapper(arg1, arg2): \\
			\s \s arg1 = arg1.capitalize() \\
			\s \s arg2 = arg2.capitalize() \\
			\s \s string\_hello = function(arg1, arg2) \\
			\s \s return string\_hello \\
			\s return wrapper \\
			@names\_decorator \\
			def say\_hello (name1,name2): \\
			\s return 'Hello ' + name1 + '! Hello ' + name2 + '!' \\
			say\_hello('sara','ansh') \# output => 'Hello Sara! Hello Ansh!
		}
	}
	
	\item \textbf{What are Dict and List comprehensions?}
	
	\answer{
		Python comprehensions, like decorators, are \textbf{syntactic sugar} constructs that help \textbf{build altered} and \textbf{filtered lists,} dictionaries, or sets from a given list, dictionary, or set. Using comprehensions saves a lot of time and code that might be considerably more verbose (containing more lines of code). Let's check out some examples, where comprehensions can be truly beneficial:
		
		\newlist{
			\item \textbf{Performing mathematical operations on the entire list}
			
			\codeblock{
				my\_list = [2, 3, 5, 7, 11] \\
				squared\_list = [x**2 for x in my\_list]    \# list comprehension \\
				\# output => [4 , 9 , 25 , 49 , 121] \\
				squared\_dict = {x:x**2 for x in my\_list}    \# dict comprehension \\
				\# output => \{11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49 \}
			}
			\item \textbf{Performing conditional filtering operations on the entire list }
			
			\codeblock{
				my\_list = [2, 3, 5, 7, 11] \\
				squared\_list = [x**2 for x in my\_ist if x\%2 != 0]     \# list comprehension \\
				\# output => [9 , 25 , 49 , 121] \\
				squared\_dict = \{x:x**2 for x in my\_list if x\%2 != 0\}   \# dict comprehension \\
				\# output => \{11: 121, 3: 9 , 5: 25 , 7: 49\} 
			}
			
			
			\item \textbf{Combining multiple lists into one} \\
			Comprehensions allow for multiple iterators and hence, can be used to combine multiple lists into one.
			
			\codeblock{
				a = [1, 2, 3] \\
				b = [7, 8, 9] \\
				\[(x + y) for (x,y) in zip(a,b)\] \# parallel iterators \\
				\# output => [8, 10, 12] \\
				\[(x,y) for x in a for y in b\] \# nested iterators \\
				\# output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] 
			}
			
			\newpage
			
			\item \textbf{Flattening a multi-dimensional list} \\       
			A similar approach of nested iterators (as above) can be applied to flatten a multi-dimensional list or work upon its inner element
			
			\codeblock{
				my\_list = [[10,20,30],[40,50,60],[70,80,90]] \\
				flattened = [x \textbf{for} temp in my\_list \textbf{for} x \textbf{in} temp] \\
				\# output => [10, 20, 30, 40, 50, 60, 70, 80, 90]
			}  
		}
		
	
	}
	
}    

  

